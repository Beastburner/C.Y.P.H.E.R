import { getValue } from '../utils/storageHelpers';

interface EtherscanTransaction {
  blockNumber: string;
  timeStamp: string;
  hash: string;
  nonce: string;
  blockHash: string;
  transactionIndex: string;
  from: string;
  to: string;
  value: string;
  gas: string;
  gasPrice: string;
  gasUsed: string;
  isError: string;
  txreceipt_status: string;
  input: string;
  contractAddress: string;
  cumulativeGasUsed: string;
  confirmations: string;
}

interface EtherscanResponse {
  status: string;
  message: string;
  result: EtherscanTransaction[];
}

interface Transaction {
  id: string;
  hash: string;
  from: string;
  to: string;
  value: string;
  timestamp: Date;
  status: 'pending' | 'confirmed' | 'failed';
  type: 'send' | 'receive' | 'contract';
  gasUsed: string;
  gasPrice: string;
  network: string;
  blockNumber?: number;
  confirmations?: number;
  data?: string;
  contractAddress?: string;
}

interface CachedTransactions {
  transactions: Transaction[];
  timestamp: number;
}

class TransactionHistoryService {
  private cache: Map<string, CachedTransactions> = new Map();
  private readonly CACHE_DURATION = 300000; // 5 minutes

  constructor() {
    this.cache = new Map();
  }

  /**
   * Get transaction history for a wallet address
   */
  async getTransactionHistory(
    address: string,
    network: string = 'mainnet',
    page: number = 1,
    pageSize: number = 25
  ): Promise<Transaction[]> {
    const cacheKey = `${address}-${network}-${page}-${pageSize}`;
    const cached = this.cache.get(cacheKey);
    
    // Return cached data if still valid
    if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
      return cached.transactions;
    }

    try {
      // Try Etherscan API first
      let transactions = await this.fetchFromEtherscan(address, network, page, pageSize);
      
      // Fallback to RPC if Etherscan fails
      if (transactions.length === 0) {
        transactions = await this.fetchFromRPC(address, network, pageSize);
      }
      
      // Cache the results
      this.cache.set(cacheKey, {
        transactions,
        timestamp: Date.now(),
      });
      
      return transactions;
    } catch (error) {
      console.error('Error fetching transaction history:', error);
      return [];
    }
  }

  /**
   * Fetch transactions from Etherscan API
   */
  private async fetchFromEtherscan(
    address: string,
    network: string,
    page: number,
    pageSize: number
  ): Promise<Transaction[]> {
    try {
      const apiKey = await getValue('ETHERSCAN_API_KEY') || '';
      const baseUrl = this.getEtherscanBaseUrl(network);
      
      if (!baseUrl) {
        return [];
      }

      const url = `${baseUrl}/api?module=account&action=txlist&address=${address}&startblock=0&endblock=99999999&page=${page}&offset=${pageSize}&sort=desc&apikey=${apiKey}`;
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data: EtherscanResponse = await response.json();
      
      if (data.status === '1' && data.result) {
        return this.parseEtherscanTransactions(data.result, address, network);
      }
      
      return [];
    } catch (error) {
      console.error('Error fetching from Etherscan:', error);
      return [];
    }
  }

  /**
   * Fetch transactions using RPC methods (fallback)
   */
  private async fetchFromRPC(
    address: string,
    network: string,
    pageSize: number
  ): Promise<Transaction[]> {
    try {
      // Implementation would depend on RPC provider
      // This is a placeholder for RPC-based transaction fetching
      console.log('RPC fallback not fully implemented yet');
      return [];
    } catch (error) {
      console.error('Error fetching from RPC:', error);
      return [];
    }
  }

  /**
   * Parse Etherscan transaction data to our format
   */
  private parseEtherscanTransactions(
    etherscanTxs: EtherscanTransaction[],
    userAddress: string,
    network: string
  ): Transaction[] {
    return etherscanTxs.map(tx => {
      const isReceive = tx.to.toLowerCase() === userAddress.toLowerCase();
      const value = this.weiToEth(tx.value);
      
      return {
        id: tx.hash,
        hash: tx.hash,
        from: tx.from,
        to: tx.to,
        value,
        timestamp: new Date(parseInt(tx.timeStamp) * 1000),
        status: tx.isError === '0' ? 'confirmed' : 'failed',
        type: tx.input === '0x' ? (isReceive ? 'receive' : 'send') : 'contract',
        gasUsed: tx.gasUsed,
        gasPrice: tx.gasPrice,
        network,
        blockNumber: parseInt(tx.blockNumber),
        confirmations: parseInt(tx.confirmations),
        data: tx.input,
        contractAddress: tx.contractAddress || undefined,
      };
    });
  }

  /**
   * Get Etherscan base URL for different networks
   */
  private getEtherscanBaseUrl(network: string): string | null {
    const urls: { [key: string]: string } = {
      'mainnet': 'https://api.etherscan.io',
      'goerli': 'https://api-goerli.etherscan.io',
      'sepolia': 'https://api-sepolia.etherscan.io',
      'polygon': 'https://api.polygonscan.com',
      'bsc': 'https://api.bscscan.com',
      'arbitrum': 'https://api.arbiscan.io',
      'optimism': 'https://api-optimistic.etherscan.io',
    };
    
    return urls[network] || null;
  }

  /**
   * Convert Wei to ETH
   */
  private weiToEth(wei: string): string {
    const ethValue = parseInt(wei) / Math.pow(10, 18);
    return ethValue.toFixed(6);
  }

  /**
   * Get pending transactions (would require WebSocket or frequent polling)
   */
  async getPendingTransactions(address: string, network: string): Promise<Transaction[]> {
    // This would require WebSocket connection or frequent polling
    // For now, return empty array
    return [];
  }

  /**
   * Get transaction details by hash
   */
  async getTransactionDetails(hash: string, network: string): Promise<Transaction | null> {
    try {
      const apiKey = await getValue('ETHERSCAN_API_KEY') || '';
      const baseUrl = this.getEtherscanBaseUrl(network);
      
      if (!baseUrl) {
        return null;
      }

      const url = `${baseUrl}/api?module=proxy&action=eth_getTransactionByHash&txhash=${hash}&apikey=${apiKey}`;
      
      const response = await fetch(url);
      const data = await response.json();
      
      if (data.result) {
        // Parse single transaction
        const tx = data.result;
        return {
          id: tx.hash,
          hash: tx.hash,
          from: tx.from,
          to: tx.to,
          value: this.weiToEth(tx.value),
          timestamp: new Date(),
          status: 'confirmed',
          type: tx.input === '0x' ? 'send' : 'contract',
          gasUsed: tx.gas,
          gasPrice: tx.gasPrice,
          network,
          data: tx.input,
        };
      }
      
      return null;
    } catch (error) {
      console.error('Error fetching transaction details:', error);
      return null;
    }
  }

  /**
   * Clear cached transaction data
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Format transaction for display
   */
  formatTransactionForDisplay(tx: Transaction): {
    displayValue: string;
    displayDate: string;
    displayStatus: string;
    displayType: string;
    shortHash: string;
  } {
    return {
      displayValue: `${parseFloat(tx.value).toFixed(4)} ETH`,
      displayDate: this.formatRelativeTime(tx.timestamp),
      displayStatus: tx.status.charAt(0).toUpperCase() + tx.status.slice(1),
      displayType: tx.type.charAt(0).toUpperCase() + tx.type.slice(1),
      shortHash: `${tx.hash.substring(0, 6)}...${tx.hash.substring(tx.hash.length - 4)}`,
    };
  }

  /**
   * Format relative time
   */
  private formatRelativeTime(date: Date): string {
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);

    if (minutes < 1) return 'Just now';
    if (minutes < 60) return `${minutes}m ago`;
    if (hours < 24) return `${hours}h ago`;
    return `${days}d ago`;
  }
}

export default TransactionHistoryService;
